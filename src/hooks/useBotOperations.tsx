
import { useState, useEffect, useRef } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/hooks/useAuth';
import { toast } from 'sonner';

export interface BotSession {
  id: string;
  user_id: string;
  session_start: string;
  session_end: string | null;
  is_active: boolean;
  error_count: number;
  questions_processed: number;
  successful_answers: number;
}

export interface QuestionAnswered {
  id: string;
  subreddit_name: string;
  reddit_post_id: string;
  question_title: string;
  question_content: string | null;
  question_author: string;
  generated_answer: string;
  reddit_comment_id: string | null;
  status: string;
  created_at: string;
  upvotes: number;
  downvotes: number;
}

export const useBotOperations = () => {
  const { user } = useAuth();
  const [currentSession, setCurrentSession] = useState<BotSession | null>(null);
  const [isRunning, setIsRunning] = useState(false);
  const [recentActivities, setRecentActivities] = useState<QuestionAnswered[]>([]);
  const intervalRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const [dailyCommentCount, setDailyCommentCount] = useState(0);
  const [errorCount, setErrorCount] = useState(0);
  const [lastErrorTime, setLastErrorTime] = useState<Date | null>(null);
  const [apiCallCount, setApiCallCount] = useState(0);
  const [lastApiReset, setLastApiReset] = useState(Date.now());
  const [isShadowbanned, setIsShadowbanned] = useState(false);

  // REDDIT COMPLIANCE: Very conservative limits to prevent suspension
  const DAILY_COMMENT_LIMIT = 5; // Reduced from 10
  const HOURLY_COMMENT_LIMIT = 2; // Reduced from 3
  const MAX_ERRORS_BEFORE_COOLDOWN = 2; // Reduced from 3
  const COOLDOWN_DURATION = 60 * 60 * 1000; // Increased to 60 minutes
  const MIN_DELAY_BETWEEN_POSTS = 2 * 60 * 1000; // 2 minutes minimum
  const MAX_DELAY_BETWEEN_POSTS = 4 * 60 * 1000; // 4 minutes maximum
  const API_RATE_LIMIT = 50; // Stay under 60 req/min
  const API_RESET_INTERVAL = 60 * 1000; // Reset API counter every minute
  const SHADOWBAN_DETECTION_THRESHOLD = 5; // Consecutive 401s indicate shadowban

  // Bot identification message - REDDIT COMPLIANCE
  const BOT_DISCLAIMER = "\n\n---\n*I'm an automated helper bot. This response was generated by AI to help answer your question.*";

  // Track recent answers to avoid duplicates - REDDIT COMPLIANCE
  const [recentAnswers, setRecentAnswers] = useState<string[]>([]);

  // API rate limiting
  const checkApiRateLimit = () => {
    const now = Date.now();
    if (now - lastApiReset > API_RESET_INTERVAL) {
      setApiCallCount(0);
      setLastApiReset(now);
    }
    return apiCallCount < API_RATE_LIMIT;
  };

  // Get random delay with jitter - REDDIT COMPLIANCE
  const getRandomDelay = (min: number, max: number) => {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };

  // Check if we're in cooldown period due to errors
  const isInCooldown = () => {
    if (!lastErrorTime || errorCount < MAX_ERRORS_BEFORE_COOLDOWN) return false;
    const timeSinceLastError = Date.now() - lastErrorTime.getTime();
    return timeSinceLastError < COOLDOWN_DURATION;
  };

  // Shadowban detection - REDDIT COMPLIANCE
  const detectShadowban = (consecutiveErrors: number) => {
    if (consecutiveErrors >= SHADOWBAN_DETECTION_THRESHOLD) {
      setIsShadowbanned(true);
      toast.error('ðŸš¨ Account may be shadowbanned! Bot will pause for safety.');
      return true;
    }
    return false;
  };

  // Check if answer is similar to recent ones - REDDIT COMPLIANCE
  const isSimilarAnswer = (newAnswer: string) => {
    const words = newAnswer.toLowerCase().split(' ').slice(0, 20); // First 20 words
    const signature = words.join(' ');
    
    return recentAnswers.some(recent => {
      const recentWords = recent.toLowerCase().split(' ').slice(0, 20);
      const recentSignature = recentWords.join(' ');
      
      // Check for 70% similarity
      const similarity = calculateSimilarity(signature, recentSignature);
      return similarity > 0.7;
    });
  };

  // Simple similarity calculation
  const calculateSimilarity = (str1: string, str2: string) => {
    const words1 = str1.split(' ');
    const words2 = str2.split(' ');
    const commonWords = words1.filter(word => words2.includes(word));
    return commonWords.length / Math.max(words1.length, words2.length);
  };

  // Check daily comment limits
  const checkDailyLimits = async () => {
    if (!user) return false;

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const { data: todayComments } = await supabase
      .from('questions_answered')
      .select('id')
      .eq('user_id', user.id)
      .eq('status', 'posted')
      .gte('created_at', today.toISOString());

    const todayCount = todayComments?.length || 0;
    setDailyCommentCount(todayCount);

    if (todayCount >= DAILY_COMMENT_LIMIT) {
      console.log(`ðŸ›‘ Daily comment limit reached (${todayCount}/${DAILY_COMMENT_LIMIT})`);
      toast.warning(`Daily comment limit reached (${todayCount}/${DAILY_COMMENT_LIMIT}). Bot will pause until tomorrow.`);
      return false;
    }

    // Check hourly limit - REDDIT COMPLIANCE
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
    const { data: hourlyComments } = await supabase
      .from('questions_answered')
      .select('id')
      .eq('user_id', user.id)
      .eq('status', 'posted')
      .gte('created_at', oneHourAgo.toISOString());

    const hourlyCount = hourlyComments?.length || 0;
    if (hourlyCount >= HOURLY_COMMENT_LIMIT) {
      console.log(`â³ Hourly comment limit reached (${hourlyCount}/${HOURLY_COMMENT_LIMIT}). Waiting...`);
      return false;
    }

    return true;
  };

  // Enhanced question detection - REDDIT COMPLIANCE (only unanswered questions)
  const isUnansweredQuestion = (title: string, content: string = '', numComments: number = 0) => {
    // Only answer threads with 0-2 existing comments - REDDIT COMPLIANCE
    if (numComments > 2) return false;
    
    const text = (title + ' ' + content).toLowerCase().trim();
    
    // Skip if text is too short or too long
    if (text.length < 20 || text.length > 1500) return false;
    
    // Skip problematic patterns - REDDIT COMPLIANCE
    const skipPatterns = [
      'upvote', 'downvote', 'karma', 'gold', 'award',
      'mod', 'moderator', 'ban', 'remove',
      'nsfw', 'explicit', 'sexual',
      'political', 'controversial', 'opinion',
      'best', 'worst', 'favorite', 'hate'
    ];
    
    if (skipPatterns.some(pattern => text.includes(pattern))) {
      return false;
    }
    
    // Check for question markers
    if (text.includes('?')) return true;
    
    // Check for question starters - more selective
    const questionStarters = [
      'how do i', 'how can i', 'what is', 'why does', 'when should',
      'where can', 'which one', 'who knows', 'what should',
      'can someone explain', 'does anyone know', 'help me understand',
      'looking for advice', 'need help with', 'not sure how'
    ];
    
    return questionStarters.some(starter => text.includes(starter));
  };

  // Start bot session
  const startBot = async (subreddits: string[]) => {
    if (!user) {
      toast.error('Please sign in to start the bot');
      return false;
    }

    // Check for shadowban
    if (isShadowbanned) {
      toast.error('Account appears to be shadowbanned. Please wait 24 hours before retrying.');
      return false;
    }

    // Check if we're in cooldown
    if (isInCooldown()) {
      const remainingTime = Math.ceil((COOLDOWN_DURATION - (Date.now() - (lastErrorTime?.getTime() || 0))) / 60000);
      toast.error(`Bot is in cooldown mode. Please wait ${remainingTime} minutes.`);
      return false;
    }

    try {
      console.log('ðŸš€ Starting Reddit-compliant bot session for user:', user.id);
      
      // Create new session
      const { data: session, error } = await supabase
        .from('bot_sessions')
        .insert({
          user_id: user.id,
          is_active: true,
        })
        .select()
        .single();

      if (error) {
        console.error('Error creating session:', error);
        toast.error('Failed to start bot session');
        return false;
      }

      console.log('âœ… Reddit-compliant bot session created:', session);
      setCurrentSession(session);
      setIsRunning(true);

      // Reset error count and shadowban status
      setErrorCount(0);
      setIsShadowbanned(false);

      // Start compliant monitoring loop
      startComplianceMonitoring(session.id, subreddits);
      
      toast.success('ðŸ¤– Reddit-compliant bot started! Following all anti-spam guidelines.');
      return true;
    } catch (error) {
      console.error('Error starting bot:', error);
      toast.error('Failed to start bot');
      return false;
    }
  };

  // Stop bot session
  const stopBot = async () => {
    if (!currentSession) return;

    try {
      console.log('ðŸ›‘ Stopping bot session:', currentSession.id);
      
      // Stop monitoring loop
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }

      // Update session
      const { error } = await supabase
        .from('bot_sessions')
        .update({
          is_active: false,
          session_end: new Date().toISOString(),
        })
        .eq('id', currentSession.id);

      if (error) {
        console.error('Error stopping session:', error);
      }

      setCurrentSession(null);
      setIsRunning(false);
      toast.success('Bot stopped');
    } catch (error) {
      console.error('Error stopping bot:', error);
      toast.error('Failed to stop bot');
    }
  };

  // Reddit-compliant monitoring with proper timing
  const startComplianceMonitoring = (sessionId: string, subreddits: string[]) => {
    console.log('ðŸ” Starting REDDIT-COMPLIANT monitoring for subreddits:', subreddits);
    
    const complianceMonitorLoop = async () => {
      if (!user) {
        console.log('âŒ No user found, stopping monitoring');
        return;
      }

      console.log('=== ðŸ¤– Starting REDDIT-COMPLIANT monitoring cycle ===');

      // Check shadowban status
      if (isShadowbanned) {
        console.log('ðŸš« Account shadowbanned, stopping monitoring');
        await stopBot();
        return;
      }

      // Check API rate limits
      if (!checkApiRateLimit()) {
        console.log('â¸ï¸ API rate limit reached, skipping cycle');
        return;
      }

      // Check if we're in cooldown
      if (isInCooldown()) {
        console.log('â¸ï¸ Bot in cooldown mode, skipping cycle');
        return;
      }

      // Check daily limits
      const canContinue = await checkDailyLimits();
      if (!canContinue) {
        console.log('ðŸ›‘ Daily/hourly limits reached, pausing bot');
        await stopBot();
        return;
      }

      // Process only ONE subreddit per cycle - REDDIT COMPLIANCE
      const randomSubreddit = subreddits[Math.floor(Math.random() * subreddits.length)];

      try {
        console.log(`ðŸ” Checking r/${randomSubreddit} (Reddit-compliant mode)...`);
        
        // Increment API call counter
        setApiCallCount(prev => prev + 1);
        
        // Get questions from Reddit
        const response = await supabase.functions.invoke('reddit-api', {
          body: {
            action: 'getQuestions',
            subredditName: randomSubreddit,
          },
        });

        if (response.error) {
          console.error(`âŒ Reddit API error for r/${randomSubreddit}:`, response.error);
          
          // Handle consecutive errors for shadowban detection
          const newErrorCount = errorCount + 1;
          setErrorCount(newErrorCount);
          setLastErrorTime(new Date());
          
          // Check for shadowban
          if (detectShadowban(newErrorCount)) {
            await stopBot();
            return;
          }
          
          toast.error(`Error accessing r/${randomSubreddit}: ${response.error.message}`);
          return;
        }

        // Reset error count on successful API call
        setErrorCount(0);

        const { questions } = response.data || {};
        
        if (!questions || questions.length === 0) {
          console.log(`ðŸ“­ No posts found in r/${randomSubreddit}`);
          return;
        }

        console.log(`ðŸ“¥ Found ${questions.length} posts in r/${randomSubreddit}`);
        
        // Filter for unanswered questions - REDDIT COMPLIANCE
        const unansweredQuestions = questions.filter((post: any) => 
          isUnansweredQuestion(post.title, post.selftext, post.num_comments) && 
          post.score >= 2 // Only answer posts with some engagement
        );
        
        console.log(`â“ Filtered to ${unansweredQuestions.length} unanswered questions in r/${randomSubreddit}`);
        
        if (unansweredQuestions.length === 0) {
          console.log(`â­ï¸ No unanswered questions detected in r/${randomSubreddit}, skipping`);
          return;
        }
        
        // Process only the TOP unanswered question - REDDIT COMPLIANCE
        const topQuestion = unansweredQuestions
          .sort((a: any, b: any) => b.score - a.score)[0];

        try {
          console.log(`ðŸ”„ Processing top unanswered question: "${topQuestion.title}" (Score: ${topQuestion.score}, Comments: ${topQuestion.num_comments})`);
          
          // Check if we've already answered this question
          const { data: existing } = await supabase
            .from('questions_answered')
            .select('id')
            .eq('reddit_post_id', topQuestion.id)
            .eq('user_id', user.id)
            .maybeSingle();

          if (existing) {
            console.log(`âœ… Already answered question ${topQuestion.id}, skipping`);
            return;
          }

          // Final limit check before generating answer
          const canPost = await checkDailyLimits();
          if (!canPost) {
            console.log('ðŸ›‘ Hit limits during processing, stopping');
            await stopBot();
            return;
          }

          console.log('ðŸ¤– Generating answer with Gemini AI...');
          
          // Increment API call counter
          setApiCallCount(prev => prev + 1);
          
          // Generate answer using Gemini
          const aiResponse = await supabase.functions.invoke('gemini-ai', {
            body: {
              question: topQuestion.selftext || topQuestion.title,
              title: topQuestion.title,
              subreddit: randomSubreddit,
            },
          });

          if (aiResponse.error) {
            console.error('âŒ Gemini AI error:', aiResponse.error);
            throw new Error(`AI generation failed: ${aiResponse.error.message}`);
          }

          const { answer } = aiResponse.data;
          if (!answer) {
            console.error('âŒ No answer generated by AI');
            throw new Error('AI did not generate an answer');
          }

          // Check for answer similarity - REDDIT COMPLIANCE
          if (isSimilarAnswer(answer)) {
            console.log('âš ï¸ Answer too similar to recent ones, skipping to avoid spam detection');
            return;
          }
          
          console.log('âœ… Generated unique answer:', answer.substring(0, 100) + '...');

          // Add bot disclaimer - REDDIT COMPLIANCE
          const finalAnswer = answer + BOT_DISCLAIMER;

          // REDDIT COMPLIANCE: Wait 2-4 minutes between posts with random jitter
          const postDelay = getRandomDelay(MIN_DELAY_BETWEEN_POSTS, MAX_DELAY_BETWEEN_POSTS);
          console.log(`â±ï¸ Waiting ${postDelay/1000}s before posting (Reddit compliance)...`);
          await new Promise(resolve => setTimeout(resolve, postDelay));

          // Increment API call counter
          setApiCallCount(prev => prev + 1);

          // Post comment to Reddit
          console.log('ðŸ“¤ Posting comment to Reddit (compliance mode)...');
          const commentResponse = await supabase.functions.invoke('reddit-api', {
            body: {
              action: 'postComment',
              postId: topQuestion.id,
              comment: finalAnswer,
            },
          });

          let commentId = null;
          let status = 'failed';

          if (!commentResponse.error && commentResponse.data?.success) {
            commentId = commentResponse.data.commentId;
            status = 'posted';
            console.log('ðŸŽ‰ Successfully posted compliant comment:', commentId);
            
            // Add to recent answers for similarity checking
            setRecentAnswers(prev => [...prev.slice(-4), answer]); // Keep last 5 answers
            
            toast.success(`âœ… Answer posted to r/${randomSubreddit}! (${dailyCommentCount + 1}/${DAILY_COMMENT_LIMIT} today)`);
            
            // Reset error count on successful post
            setErrorCount(0);
          } else {
            console.error('âŒ Failed to post comment:', commentResponse.error);
            const newErrorCount = errorCount + 1;
            setErrorCount(newErrorCount);
            setLastErrorTime(new Date());
            
            // Check for shadowban
            if (detectShadowban(newErrorCount)) {
              await stopBot();
              return;
            }
            
            toast.error(`Failed to post answer: ${commentResponse.error?.message || 'Unknown error'}`);
          }

          // Save to database
          const { error: saveError } = await supabase
            .from('questions_answered')
            .insert({
              user_id: user.id,
              session_id: sessionId,
              subreddit_name: randomSubreddit,
              reddit_post_id: topQuestion.id,
              question_title: topQuestion.title,
              question_content: topQuestion.selftext || null,
              question_author: topQuestion.author,
              generated_answer: finalAnswer,
              reddit_comment_id: commentId,
              status: status,
            });

          if (saveError) {
            console.error('âŒ Error saving answer:', saveError);
          } else {
            console.log('ðŸ’¾ Answer saved to database successfully');
          }

          // Update session stats
          await supabase
            .from('bot_sessions')
            .update({
              questions_processed: currentSession ? currentSession.questions_processed + 1 : 1,
              successful_answers: status === 'posted' ? 
                (currentSession ? currentSession.successful_answers + 1 : 1) : 
                (currentSession ? currentSession.successful_answers : 0),
            })
            .eq('id', sessionId);

          console.log(`âœ… Completed Reddit-compliant processing: ${topQuestion.title} - Status: ${status}`);

        } catch (error) {
          console.error('âŒ Error processing question:', error);
          const newErrorCount = errorCount + 1;
          setErrorCount(newErrorCount);
          setLastErrorTime(new Date());
          
          // Check for shadowban
          if (detectShadowban(newErrorCount)) {
            await stopBot();
            return;
          }
          
          toast.error(`Error processing question: ${error.message}`);
          
          // Update error count
          await supabase
            .from('bot_sessions')
            .update({
              error_count: currentSession ? currentSession.error_count + 1 : 1,
            })
            .eq('id', sessionId);
        }
      } catch (error) {
        console.error(`âŒ Error monitoring r/${randomSubreddit}:`, error);
        const newErrorCount = errorCount + 1;
        setErrorCount(newErrorCount);
        setLastErrorTime(new Date());
        
        // Check for shadowban
        if (detectShadowban(newErrorCount)) {
          await stopBot();
          return;
        }
        
        toast.error(`Error monitoring r/${randomSubreddit}: ${error.message}`);
      }

      console.log('=== ðŸ¤– REDDIT-COMPLIANT monitoring cycle completed ===');
    };

    // Run immediately once
    complianceMonitorLoop();
    
    // Then run every 3-5 minutes with random jitter - REDDIT COMPLIANCE
    const baseInterval = getRandomDelay(3 * 60 * 1000, 5 * 60 * 1000);
    intervalRef.current = setInterval(complianceMonitorLoop, baseInterval);
  };

  // Fetch recent activities
  const fetchRecentActivities = async () => {
    if (!user) return;

    try {
      const { data, error } = await supabase
        .from('questions_answered')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false })
        .limit(20);

      if (error) {
        console.error('Error fetching activities:', error);
        return;
      }

      setRecentActivities(data || []);
    } catch (error) {
      console.error('Error fetching activities:', error);
    }
  };

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);

  // Fetch activities on user change
  useEffect(() => {
    if (user) {
      fetchRecentActivities();
    } else {
      setRecentActivities([]);
    }
  }, [user]);

  // Load daily comment count on startup
  useEffect(() => {
    if (user) {
      checkDailyLimits();
    }
  }, [user]);

  return {
    currentSession,
    isRunning,
    recentActivities,
    startBot,
    stopBot,
    fetchRecentActivities,
    dailyCommentCount,
    dailyLimit: DAILY_COMMENT_LIMIT,
    isInCooldown: isInCooldown(),
    errorCount,
    isShadowbanned,
    apiCallCount,
    apiRateLimit: API_RATE_LIMIT,
  };
};
